#include <video.h>
#include <string.h>
#include <mm/mm.h>

#ifdef ARCH_X86
#include <kernel/arch/x86/dev/vga/print.h>
#endif

/**
 * \brief Prints a single character.
 * Uses the current architecture's put function
 * @param c the input character
 */
void kput(char c)
{
#ifdef ARCH_X86
	vga_put((u8)c);
#endif
}

/**
 * \brief Prints a single wide character.
 * Uses the current architecture's (w)put function
 * @param c the input character
 */
void kwput(int c)
{
#ifdef ARCH_X86
	vga_put((u8)c);
#endif
}

/**
 * \brief Prints a string of characters.
 * Uses the kput function
 * @param str the input string
 * @see kput
 */
void kprint(char *str)
{
	while(*str) kput(*str++);
}

/**
 * \brief Prints a string of wide characters.
 * Uses the kwput function
 * @param str the input string
 * @see kwput
 */
void kwprint(short *str)
{
	while(*str) kwput(*str++);
}

/**
 * \brief Prints a number using the specified base.
 * Prints a number using any base between 2 and 16, inclusive.
 * @param n number to be printed
 * @param base base to use when printing the number
 * @see kput
 */
void kprintnum(u32 num, int base)
{
	char nums[16] = "0123456789ABCDEF";
	char ans[16] = { '0' };
	int i = 0;
	while(num)
	{
		ans[i++] = nums[num % base];
		num /= base;
	}
	if(i == 0) i++;
	
	for(i--; i >= 0; i--)
		kput(ans[i]);
}




/**
 * \brief Converts an integer to a string.
 * Converts an interger into a string and places the output into `out`
 * Used by `print` to make the code cleaner.
 * @param num the number to print
 * @param base the base in which to print the number
 * @param u wether the number is unsigned
 * @param pad how many characters of padding to give the number
 * @param padzero wether or not to pad the number with zeros instead of spaces
 * @param possign wether or not to place a positive sign in front of positive numbers
 * @param posspace wether or not to place a space in front of positive numbers
 * @param _case upper or lowercase (for bases above 10)
 * @param out the output string/buffer
 * @return the number of characters that have been put in `out`
 * @see print
 */
static int print_int(u32 num, int base, int u, int pad, int padzero, int possign, int posspace, int _case, char *out)
{
	int onum = num;
	char *nums;
	if(!u) num &= ~(0x80000000); // Throw away the sign bit for now
	if(_case) nums = "0123456789ABCDEF";
	else      nums = "0123456789abcdef";
	
	char ans[16] = { '0', 0, };
	int i = 0;
	while(num)
	{
		ans[i++] = nums[num % base];
		num /= base;
	}
	if(i == 0) i++;
	
	if(!u)
	{
		if(onum > 0)
		{
			if(possign)
			{
				if(onum > 0)
					*out++ = '+';
			}
			else if(posspace)
				if(onum < 0)
					*out++ = ' ';
		}
		else if(onum < 0)
			*out++ = '-';
	}
	
	int p = pad - i;
	if(p > 0)
	{
		while(p--) *out++ = (padzero ? '0' : ' ');
		while(--i > -2) *out++ = ans[i];
		return pad + ((((possign || posspace) && !u) && onum > 0) || ((onum < 0) && !u));
	}
	else
	{
		while(--i > -2) *out++ = ans[i];
		return strlen(ans) + ((((possign || posspace) && !u) && onum > 0) || ((onum < 0) && !u));
	}
}


/**
 * \brief Convert a number in a string into an integer.
 * Convert a number in a string into an integer. Used by `print` to make code cleaner.
 * @param str input string
 * @param out pointer to end of number (generated by this function)
 * @return the number found
 * @see print
 */
static int get_dec(char *str, char **out)
{
	int n = 0;
	while(*str >= '0' && *str <= '9')
	{
		n *= 10;
		n += (int)(*str - '0');
		str++;
	}
	*out = str;
	
	return n;
}

/**
 * \brief A helper function for sprintf/kprintf/etc...
 * Takes a format string and a list of arguments as input, and produces a
 * string as output.
 * @param out the output string
 * @param format the format string
 * @param varg the list of arguments
 * @return the number of charactern placed in `out`
 */
static int print(char *out, char *format, int *varg)
{
	int is_in_spec = 0;
	int size = 0;      // Size of the integer
	int width = 0;     // Width of the number at minimum
	int precision = 0; // Precision
	int showsign = 0;  // Show the sign on positive numbers
	int signspace = 0; // Place a space before positive numbers
	int leftalign = 0; // Align to the left
	int padzeros = 0;  // Use zeros instead of spaces for padding
	
	int nchars = 0;    // Number of chars printed so far
	
	format--;
	while(*++format)
	{
		if(!is_in_spec)
		{
			if(*format == FMT_SPEC)
			{
				is_in_spec = 1;
				continue;
			}
			*out++ = *format;
			continue;
		}
		
		if(*format == FMT_SPEC)
		{
			is_in_spec = 0;
			*out++ = FMT_SPEC;
			continue;
		}
		
		
		if(*format == 'l')
		{
			if(size < 2)
				size++;
			continue;
		}
		
		if(*format == 'L')
		{
			size = 1;
			continue;
		}
		
		if(*format == 'h')
		{
			if(size > -2)
				size--;
			continue;
		}
		
		if(*format == 'z' || *format == 'j' || *format == 't')
		{
			size = 0;
			continue;
		}
		
		if(*format == '+')
		{
			showsign = 1;
			continue;
		}
		
		if(*format == ' ')
		{
			signspace = 1;
			continue;
		}
		
		if(*format == '-')
		{
			leftalign = 1;
			continue;
		}
		
		if(*format == '0')
		{
			padzeros = 1;
			continue;
		}
		
		if(*format >= '0' && *format <= '9')
		{
			width = get_dec(format, &format);
			format--;
			continue;
		}
		
		if(*format == '.')
		{
			precision = get_dec(format, &format);
			format--;
			continue;
		}
		
		
		if(IS_SPEC(*format))
		{
			if(DECIMAL_SPEC(*format))
			{
				int n = *varg++;
				if(size == -1) n &= 0xFFFF;
				if(size == -2) n &= 0xFF;
				if(size == 2){} // TODO: Handle this!
				int i = print_int(n, 10, 0, width, padzeros, showsign, signspace, 0, out);
				nchars += i;
				out += i;
			}
			
			if(UNSIGNED_SPEC(*format))
			{
				u32 n = *varg++;
				if(size == -1) n &= 0xFFFF;
				if(size == -2) n &= 0xFF;
				if(size == 2){} // TODO: Handle this!
				int i = print_int(n, 10, 1, width, padzeros, showsign, signspace, 0, out);
				nchars += i;
				out += i;
			}
			
			// Unimplemented:
			if(FDOUBLE_SPEC(*format)) varg++;
			if(EDOUBLE_SPEC(*format)) varg++;
			if(GDOUBLE_SPEC(*format)) varg++;
			
			if(HEX_SPEC(*format))
			{
				u32 n = *varg++;
				if(size == -1) n &= 0xFFFF;
				if(size == -2) n &= 0xFF;
				if(size == 2){} // TODO: Handle this!
				int i = print_int(n, 16, 1, width, padzeros, showsign, signspace, (*format == 'X'), out);
				nchars += i;
				out += i;
			}
			
			if(OCTAL_SPEC(*format))
			{
				u32 n = *varg++;
				if(size == -1) n &= 0xFFFF;
				if(size == -2) n &= 0xFF;
				if(size == 2){} // TODO: Handle this!
				int i = print_int(n, 8, 1, width, padzeros, showsign, signspace, 0, out);
				nchars += i;
				out += i;
			}
			
			if(STRING_SPEC(*format))
			{
				char *str = (char *)*varg++;
				if(size > 0)
				{
					while(*str) *out++ = *str++;
					nchars += wcslen((short *)str);
				}
				else
				{
					while(*str) *out++ = *str++;
					nchars += strlen(str);
				}
			}
			
			if(CHAR_SPEC(*format))
			{
				int ch = *varg++;
				if(size > 0) *out++ = (char)ch;
				else         *out++ = (char)ch;
				nchars++;
			}
			
			if(POINTER_SPEC(*format))
			{
				u32 i = *varg++;
				nchars += print_int(i, 16, 1, width, padzeros, showsign, signspace, 1 /* Should this be upper or lower case? */, out);
			}
			
			// Unimplemented:
			if(HEXFLOAT_SPEC(*format)) varg++;
			
			if(INUM_SPEC(*format))
			{
				*varg++ = nchars;
			}
			
			
			is_in_spec = 0;
			size       = 0;
			width      = 0;
			precision  = 0;
			showsign   = 0;
			signspace  = 0;
			leftalign  = 0;
			padzeros   = 0;
		}
		
	}
	
	*(out + 1) = 0;
	
	// These aren't used yet:
	(void)precision;
	(void)leftalign;
	
	return nchars;
}

/**
 * \brief Creates a string based on input format string and arguments.
 * Uses `print` to convert the format string and any number of arguments to
 * an output string.
 * @param out output string
 * @param format format string
 * @param ... argument list
 * @return the number of characters placed in `out`
 * @see print
 */
int sprintf(char *out, char *format, ...)
{
	int *varg = (int *)&format;
	return print(out, format, varg);
}

/**
 * \brief Creates and prints a string based on input format string and arguments.
 * Uses `print` to convert the format string and any number of arguments to
 * a string then prints that string to the screen.
 * @param format format string
 * @param ... argument list
 * @return the number of characters printed
 * @see print
 */
int kprintf(char *format, ...)
{
	int *varg = (int *)&format;
	char temp[1024];
	int ret = print(temp, format, ++varg);
	kprint(temp);
	return ret;
}
